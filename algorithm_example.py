
###############################################################################################################
############################################   Q37 _ 플로이드     #############################################
###############################################################################################################
'''
Given ) N (1 <= N <= 100) 개의 도시가 있고 한 도시에서 출발하여 다른 도시에 도착하는 m(1<=m<=100,000) 개의 버스가 있다.
        각 버스는 한번 사용할 때 필요한 비용이있다. 모든 도시의 쌍에 대해서 도시 A에서 B 로 가는데 필요한 비용의 최솟값을
        구하는 프로그램을 작성하라.
Input ) 첫째 줄에 도시의 개수 N (1 <= N <= 100) 이 주어진다
        둘째 줄에 버스의 개수 m (1 <= m <= 100,000) 이 주어진다
        셋째 줄부터는 버스의 정보가 주어진다. " 출발도시 / 도착도시 / 소요비용 " 순으로 공백으로 구분되어 주어짐
        시작도시와 도착도시를 연결하는 노선은 하나 이상이다.
Output) n개의 줄을 출력해야한다. i번째 줄에 출력하는 j번째 숫자는 i에서 j 로 이동하는 최소비용이며 i==j 일 경우 0 이다
'''

'''
1회차 > 모든 도시에서 모든 도시까지의 거리, 문제이름 "플로이드"
        플로이드 워셜 알고리즘을 사용하라는 문제이다.
'''

inf = 1e9
N = 5
m = 14
A = [[ 1, 2, 2],[ 1, 3, 3],[ 1, 4, 1],[ 1, 5, 10],[ 2, 4, 2],[ 3, 4, 1],[ 3, 5, 1],[ 4, 5, 3],[ 3, 5, 10],[ 3, 1, 8],[ 1, 4, 2],[ 5, 1, 7],[ 3, 4, 2],[ 5, 2, 4]]
data = [[inf]*N for _ in range(N)]
for x,y,z in A:
    if data[x-1][y-1] == inf:
        data[x-1][y-1] = z
    else:
        data[x-1][y-1] = min(data[x-1][y-1],z)

for i in range(N):
    for j in range(N):
            for k in range(N):
                if k == j:
                    data[j][k] = 0
                else:
                    data[j][k] = min(data[j][k],data[j][i]+data[i][k])

print(data)
            
'''
1회차 > 대표적이란 말도 창피할정도로 그냥 플로이드워셜 알고리즘 문제다. 플로이드워셜 알고리즘은 구현이 매우 쉽다 32-38 line 만 기억하고 있다면
        어떤 문제에서든지 구현이 가능하다. 하지만 나는 ijk 의 순서와 왜 그런지 다시 생각해내느라 시간이 꽤나 걸렸다.
'''