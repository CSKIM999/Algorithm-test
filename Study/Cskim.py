'''
내가 자주 틀리거나 혹은 내가 틀리고서 상당히 충격을 받은 부분을 라이브러리화 시켜서 정리하고자 한다
'''


#####################################################################################################################
#####################################################################################################################
#####################################################################################################################

import itertools
'''

파이썬의 기본 라이브러리중 하나인 itertools


product('ABCD', repeat=2) ///  AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD
>> AA,DD 는 있고 AD 와 DA 는 다른 객체이다

permutations('ABCD', 2)   ///  AB AC AD BA BC BD CA CB CD DA DB DC
>> AA,DD 는 없으나, AB 와 BA 는 다르다

combinations('ABCD', 2)   /// AB AC AD BC BD CD
>> AA,DD 도 없고 AD 와 DA 도 같다

combinations_with_replacement('ABCD', 2)  ///AA AB AC AD BB BC BD CC CD DD
>> AA와 DD 는 있으나, AD와 DA 는 다르다


'''

#####################################################################################################################
#####################################################################################################################
#####################################################################################################################

'''
다이나믹 프로그래밍 
>>  피보나치수열과 같이 전에 완성시킨 데이터를 가지고 현재의 문제에 적용해야하는 경우 다이나믹 프로그래밍을 사용하면 좋다
    빈 리스트 d 를 생성 후 d[0]과 d[1]은 직접 선언한 후 d[2] 부터는 d[0],d[1] 을이용하여 d[n]까지 삽입하면 된다.

플로이드 워셜 
>>  "모든 노드에서 모든 노드까지의 거리" 를 구하는 알고리즘. 이라고 생각하면 기억하기 쉬울 듯 하다.
    플로이드 워셜 알고리즘의 시간복잡도는 O(N^3) 이므로, 노드의 개수가 100 개 언저리일 때 모든 노드를 확인해야 할 경우 사용하면
    좋다.
'''

#####################################################################################################################
#####################################################################################################################
#####################################################################################################################

'''
내가 짜본 여러가지 함수들
'''
# 행렬 회전 함수 ( 행렬값(data) 이 변수로 들어가고 새로운 행렬 data_prime 이 반환된다 )
def rotate(data):
    n = len(data)
    m = len(data[0])
    data_prime = [[0]*n for _ in range(m)]
    for i in range(n):
        for j in range(m):
            data_prime[j][n-i-1] = data[i][j]
    return data_prime




#####################################################################################################################
#####################################################################################################################
#####################################################################################################################

'''
리스트 슬라이싱
>>> [:] 처음부터 끝까지
>>> [start:] start 인덱스부터 끝까지
>>> [:end] 처음부터 end-1 인덱스까지
>>> [start:end] start 인덱스부터 end-1 인덱스까지
>>> [start:end:step] start부터 end-1 까지 각 step 마다 ex) [::-1] // 처음부터 끝까지 역순으로
'''

'''
count_by_range(array,left,right)
>>> array 에서 left값 이상 right값 이하인 원소들을 모두 세어주는 함수
    여기서 left 와 right 은 array 안에 포함되어있지 않아도 조건문으로서 사용가능

>>> array = [1,3,5,7,9] // count_by_range(array,2,8)
    위 코드에서는 array 에서 2이상 8이하의 값을 return 해주므로 3,5,7 이 return된다.
'''
#####################################################################################################################
#####################################################################################################################
#####################################################################################################################
'''
2중 for 문 탈출 >>> 21/09/06 처음으로 for 문에서 break 이 모든걸 해결해주는것은 아니란 것을 알았다.
                    만약 2중 for 문의 안쪽 for 문에 break 를 사용했다면 안쪽 for 문에서만 탈출이 되고 바깥 for 문에의해
                    코드는 계속 실행된다.
                    여기서 만약 두개 이상의 for 문을 모두 탈출하고싶다면, 플래그를 사용하는 게 가장 간단한 사용방법이 될 것이다.

for i in range(10):
    for j in range(10):
        for k in range(10):
            if i+j+k > 15:
                print('YES')
                break
만약 위의 코드를 사용한다면 i = 0, j = 7, k = 9 에서 YES 가 출력되고 종료되는것이 아닌 계속해서 다른 숫자를 출력하게 된다
따라서 위의 코드를 flag 를 사용하여 다시 작성한다면
'''

flag = False
for i in range(10):
    for j in range(10):
        for k in range(10):
            if i+j+k > 15:
                print('YES')
                print(i,j,k)
                flag = True
                break
        if flag:
            break
    if flag:
        break

'''
와 같이 작성되며 확인을 위해 가장 먼저 if 문을 만족하는 0,7,9 가 출력되는것을 확인할 수 있다.
'''
#####################################################################################################################
#####################################################################################################################
#####################################################################################################################


