'''
내가 자주 틀리거나 혹은 내가 틀리고서 상당히 충격을 받은 부분을 라이브러리화 시켜서 정리하고자 한다
'''


#####################################################################################################################
#####################################################################################################################
#####################################################################################################################

import itertools
'''

파이썬의 기본 라이브러리중 하나인 itertools


product('ABCD', repeat=2) ///  AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD
>> AA,DD 는 있고 AD 와 DA 는 다른 객체이다
>> 중복선택이 가능하고 순서또한 따짐

permutations('ABCD', 2)   ///  AB AC AD BA BC BD CA CB CD DA DB DC
>> AA,DD 는 없으나, AB 와 BA 는 다르다
>> 중복선택이 불가하나 순서를 따짐

combinations('ABCD', 2)   /// AB AC AD BC BD CD
>> AA,DD 도 없고 AD 와 DA 도 같다
>> 중복선택이 불가하고 순서는 따지지 않음

combinations_with_replacement('ABCD', 2)  ///AA AB AC AD BB BC BD CC CD DD
>> AA와 DD 는 있으나, AD와 DA 는 같다
>> 중복선택 가능하나 순서는 따지지않음

'''

#####################################################################################################################
#####################################################################################################################
#####################################################################################################################

'''
다이나믹 프로그래밍 
>>  피보나치수열과 같이 전에 완성시킨 데이터를 가지고 현재의 문제에 적용해야하는 경우 다이나믹 프로그래밍을 사용하면 좋다
    빈 리스트 d 를 생성 후 d[0]과 d[1]은 직접 선언한 후 d[2] 부터는 d[0],d[1] 을이용하여 d[n]까지 삽입하면 된다.

플로이드 워셜 
>>  "모든 노드에서 모든 노드까지의 거리" 를 구하는 알고리즘. 이라고 생각하면 기억하기 쉬울 듯 하다.
    플로이드 워셜 알고리즘의 시간복잡도는 O(N^3) 이므로, 노드의 개수가 100 개 언저리일 때 모든 노드를 확인해야 할 경우 사용하면
    좋다.
'''

#####################################################################################################################
#####################################################################################################################
#####################################################################################################################

'''
내가 짜본 여러가지 함수들
'''
# 행렬 회전 함수 ( 행렬값(data) 이 변수로 들어가고 새로운 행렬 data_prime 이 반환된다 )


def rotate(data):
    n = len(data)
    m = len(data[0])
    data_prime = [[0]*n for _ in range(m)]
    for i in range(n):
        for j in range(m):
            data_prime[j][n-i-1] = data[i][j]
    return data_prime


#####################################################################################################################
#####################################################################################################################
#####################################################################################################################
'''
리스트 슬라이싱
>>> [:] 처음부터 끝까지
>>> [start:] start 인덱스부터 끝까지
>>> [:end] 처음부터 end-1 인덱스까지
>>> [start:end] start 인덱스부터 end-1 인덱스까지
>>> [start:end:step] start부터 end-1 까지 각 step 마다 ex) [::-1] // 처음부터 끝까지 역순으로
'''

'''
count_by_range(array,left,right)
>>> array 에서 left값 이상 right값 이하인 원소들을 모두 세어주는 함수
    여기서 left 와 right 은 array 안에 포함되어있지 않아도 조건문으로서 사용가능

>>> array = [1,3,5,7,9] // count_by_range(array,2,8)
    위 코드에서는 array 에서 2이상 8이하의 값을 return 해주므로 3,5,7 이 return된다.
'''
#####################################################################################################################
#####################################################################################################################
#####################################################################################################################
'''
2중 for 문 탈출 >>> 21/09/06 처음으로 for 문에서 break 이 모든걸 해결해주는것은 아니란 것을 알았다.
                    만약 2중 for 문의 안쪽 for 문에 break 를 사용했다면 안쪽 for 문에서만 탈출이 되고 바깥 for 문에의해
                    코드는 계속 실행된다.
                    여기서 만약 두개 이상의 for 문을 모두 탈출하고싶다면, 플래그를 사용하는 게 가장 간단한 사용방법이 될 것이다.

for i in range(10):
    for j in range(10):
        for k in range(10):
            if i+j+k > 15:
                print('YES')
                break
만약 위의 코드를 사용한다면 i = 0, j = 7, k = 9 에서 YES 가 출력되고 종료되는것이 아닌 계속해서 다른 숫자를 출력하게 된다
따라서 위의 코드를 flag 를 사용하여 다시 작성한다면
'''

flag = False
for i in range(10):
    for j in range(10):
        for k in range(10):
            if i+j+k > 15:
                print('YES')
                print(i, j, k)
                flag = True
                break
        if flag:
            break
    if flag:
        break
'''
와 같이 작성되며 확인을 위해 가장 먼저 if 문을 만족하는 0,7,9 가 출력되는것을 확인할 수 있다.
'''
#####################################################################################################################
#####################################################################################################################
#####################################################################################################################
'''
LCS 와 LIS
LCS : Longest Common Substring // Subsequence ( 최장 공통 부분 문자열 // 최장 공통 부분 수열 )
LIS : Longest Increasing Subsequence || 최장 증가 부분 수열
비슷한 개념이 세개여서 헷갈릴 수 있지만 자주, 쉽게 낼 수 있는 문제라서 알아둬야 함.

LCS 는 DP 테이블을 사용해서 푸는것이 적절.
각각의 문자열을 행,열로 설정하고 2중for문 돌려서 만약 일치하는 문자라면 i-1 혹은 j-1 중 큰 값에 +1 해서 가져오기

LIS 는 dp보단 이분탐색이 NlogN 으로 더 빠르다고 함.
1. 수열을 순회한다 => i
2. 최장 증가 부분수열을 저장할 배열을 생성
3. 배열의 마지막값과 i 를 비교한다.
    3.1 만약 크다면 배열의 마지막 값에 추가
    3.2 작다면 이분탐색을 통해 들어가야 할 위치 탐색
    3.3 같으면 무시
결과값이 최장 증가 부분 수열임.
'''
#####################################################################################################################
#####################################################################################################################
#####################################################################################################################