def xprint(a):
    for i in a:
        print(i)

###############################################################################################################################################################################################
################################################################################    Q17144 _ 미세먼지 안녕!    ################################################################################
###############################################################################################################################################################################################
'''
Given ) 미세먼지는 R*C 크기의 격자판에 1*1 크기로 흩뿌려져있다. (r,c)는 r행 c열을 의미한다.
        공청기는 항상 1열에 설치되어있고 ( 행열은 1 부터 시작한다는 뜻 ), 크기는 두 행을 차지하며 위아래로 나뉘어 작동한다
        공청기가 설치되지 않은 칸에는 미세먼지가 있고 미세먼지의 양은 A[r][c] 이다. 1초마다 다음과 같은 알고리즘으로 미세먼지와 공청기는 작동한다
        1. 미세먼지의 확산 -> 미세먼지의 확산은 미세먼지가 존재하는 모든 칸에서 동시에 일어난다
            1.1. (r,c) 에 위치한 미세먼지는 인접한 네 방향으로 확산된다.
            1.2. 인접한 방향에 공청기가 있거나, 칸이 없으면 그 방향으로는 확산이 일어나지 않는다.
            1.3. 확산되는 양은 A[r][c]/5 이고 소수점은 버린다.
            1.4. A[r][c] 에 남는 미세먼지는 A[r][c] - (A[r][c]/5)*확산된 방향의 개수 이다.
        2. 공청기의 작동
            2.1. 공청기에서는 바람이 나온다.
            2.2. 위쪽 공청기의 바람은 반시계방향으로 순환하여 되돌아오고, 아래 공청기의 바람은 시계방향으로 순환하여 되돌아온다.
            2.3. 바람이 불면 미세먼지가 바람의 방향대로 한칸씩 이동한다
            2.4. 공청기에서 나온 바람은 미세먼지가 없는 바람이고 공청기로 들어간 미세먼지는 모두 정화된다.
Input ) 첫째 줄에 R,C,T ( 6<= R,C <= 50, 1<= T <= 1000 ) 가 주어진다.
        둘째 줄부터 R 개의 줄에 A[r][c] (-1 <= A[r][c] <= 1000) 가 지어진다. 공청기가 설치된곳의 A[r][c] 는 -1 이고, 나머지 값은 미세먼지의 양이다.
        -1 은 위아래로 붙어져있고, 가장 위와 아래에서 2칸 이상 떨어져있다.
Output) T초 지난 후의 방에 남은 미세먼지양을 출력하라
'''

'''
R*C 의 최대크기는 50*50 으로 2500, 미세먼지 확산에 필요한 연산 2500 리스트로 관리할까? 확산시 각 칸에 영향을 주지 않기위해선 슬라이싱이 필요함 2500000
'''

r,c,t = 7,8,1
data = [
    [5 ,0 ,0, 0, 0, 0, 0 ,9],
    [0 ,0 ,0, 0, 3, 0, 0 ,8],
    [-1, 0, 5, 0, 0, 0, 22 ,0],
    [-1, 8, 0, 0, 0, 0, 0 ,0],
    [0 ,0 ,0 ,0, 0 ,10 ,43 ,0],
    [5 ,0 ,5 ,0, 15, 0 ,0 ,0],
    [0 ,0 ,40 ,0 ,0, 0, 20 ,0]
]

# r,c,t = 3,3,1
# data = [
#     [0,0,0],
#     [0,46,0],
#     [0,0,0]
# ]

cleaner = []
for i in range(r):
    if data[i][0] == -1:
        cleaner.append(i)
        cleaner.append(i+1)

        break
dx,dy = [-1,0,1,0],[0,1,0,-1]
temp = [[0]*c for _ in range(r)]
#확산
for i in range(r):
    for j in range(c):
        if (i == cleaner[0] or i==cleaner[1]) and j == 0:
            temp[i][j] = -1
            continue
        if data[i][j] >= 5:
            now = data[i][j]
            sep = data[i][j]//5
            count = 0
            for q in range(4):
                nx,ny = i+dx[q],j+dy[q]
                if (0<=nx<r and 0<=ny<c) and data[nx][ny] != -1:
                    count +=1
                    temp[nx][ny] += sep
            temp[i][j] += now-sep*count
        elif 0<= data[i][j] <5:
            temp[i][j] += data[i][j]
data = [i[:] for i in temp]
#공청기
tt,tb,bt,bb = data[0][:],data[cleaner[0]][:],data[cleaner[1]][:],data[-1][:]
l,r = [i[0] for i in data],[i[-1] for i in data]
tr,br = r[:cleaner[1]], r[cleaner[1]:]
tl,bl = l[:cleaner[1]], l[cleaner[1]:]


data[0][:-1] = tt[1:]
for i in range(cleaner[0]):
    data[i][-1] = tr[i+1]
    if data[i][0] != -1 and i != 0:
        data[i][0] = tl[i-1]
data[cleaner[0]][1:] = [0] + tb[1:-1]

tx,bx=cleaner[0],cleaner[1]

data[bx][1:] = [0] + bt[1:-1]
for x,i in enumerate(range(bx+1,7)):
    data[i][-1] = br[x]
    if i<6:
        data[i][0] = bl[x+2]
data[-1]= bb[1:] + [br[-2]]
print()
xprint(data)